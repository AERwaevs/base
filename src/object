#pragma once

#include <atomic>

#include <Base/ref_ptr>

template< typename T >
concept Creatable = requires( T t )
{
    T::create();
};

template< typename T >
concept Compatible = requires( T t )
{
    { t.type_info() } -> std::same_as< const std::type_info& >;
    { t.is_compatible( t.type_info ) } -> std::same_as< bool >;
};
 
class AEON_DLL Object
{
public:
    Object()                                    : _ref_num( 0 ) {}
    Object( const Object& rhs )                 : Object()      {}
    Object& operator = ( const Object& rhs )                    { return *this; }

    template< typename T, typename... Args >
    static inline auto create( Args&&... args )
    {
        return ref_ptr<T>( new T( args... ) );
    }

    template< typename... Args >
    static inline auto create( Args&&... args )
    {
        return ref_ptr<Object>( new Object( args... ) );
    }

    virtual const std::type_info& type_info() const noexcept
    {
        return typeid( Object );
    }

    virtual bool is_compatible( const std::type_info& type ) const noexcept
    {
        return type == typeid( Object );
    }

    inline unsigned int ref_count() const noexcept 
    { 
        return _ref_num.load(); 
    }

protected:
    virtual ~Object() {}

private:
    inline void ref() const noexcept 
    { 
        _ref_num.fetch_add( 1, std::memory_order_relaxed ); 
    }

    inline void unref() const noexcept 
    { 
        if ( _ref_num.fetch_sub( 1, std::memory_order_seq_cst ) <= 1 ) delete this;
    }

protected:
    template< class T >
    friend class ref_ptr;

    template< class T >
    friend struct is_referenced;

private:
    mutable std::atomic_uint _ref_num;
};